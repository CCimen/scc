# SCC Maintainability Refactoring - Agent Instructions

**Goal:** Raise maintainability from ~8.5/10 to **10/10** by eliminating orchestration monoliths, removing duplication, tightening typed boundaries, and increasing testability without Docker/Git/network.

---

# CRITICAL INSTRUCTIONS FOR THIS REFACTORING PROJECT

## How to Handle Each Task Type

### For "Phase 3 Cleanup" tasks:
- These are FIXING existing code, not writing new features
- Do NOT write new tests - instead, FIX the existing failing tests
- Focus on: fixing lint errors, fixing type errors, fixing test failures
- The goal is to make all existing tests pass

### For "Phase 4/5/6/7" tasks:
- These are REFACTORING existing code into new structure
- Create new use cases, ports, adapters following the architecture
- Move existing logic, don't rewrite from scratch
- Add characterization tests BEFORE refactoring risky flows
- Preserve ALL existing behavior (non-negotiable)

### For "Final" verification tasks:
- These are VALIDATION checks, not implementation
- Verify the criteria is met by reviewing the code
- If criteria is already met, mark complete
- If not met, fix what's needed first

## Validation Commands (RUN AFTER EVERY CHANGE)
```bash
uv run ruff format
uv run ruff check
uv run mypy src/scc_cli
uv run pytest
```

**IMPORTANT: Do not mark a task complete if any validation command fails.**

---

# NON-NEGOTIABLES (MUST FOLLOW)

1. **No behavior changes.** CLI UX, TUI flow, keybindings, messages (where locked), JSON schema/envelopes, and exit codes must remain the same.
2. **No config semantics changes.** Org/team/project layering, additive merges, non-overridable blocks, trust rules.
3. **Default backends unchanged.** Docker Desktop sandbox + Claude Code remain the default and work exactly as today.
4. **Incremental changes only.** No big-bang folder reshuffles or "rewrite everything" changes.
5. **Tests are the gate.** Add characterization tests before refactoring risky flows. Do not proceed if tests fail.

---

# ARCHITECTURE PRINCIPLES (HARD RULES)

## Dependency Direction
- `application/` may depend on: `ports/`, `core/`, `services/`, and domain models.
- `commands/` and `ui/` may depend on: `application/`, `ports/` (rare), and presentation mapping helpers.
- `adapters/` may depend on: external libs + legacy modules, but **must not import `ui/`**.
- `application/` **MUST NEVER import** `ui/`, `commands/`, `typer`, `rich`, `subprocess`, or direct Docker/requests/zipfile usage.

## Functional Core / Imperative Shell
- Use cases return **typed results + view models + InteractionRequests**.
- Side effects happen via ports (Filesystem/Git/Runtime/Fetcher/etc.) or at the CLI/UI edges.

## Error Strategy (Single Rule)
- **Use cases return success models and raise typed `SCCError` for failures.**
- Commands/UI map errors to: exit codes, human messages/panels, JSON envelope payloads via shared error mapping and edge JSON mapping helpers.

## Interaction Model (No Prompts in Core)
- Use cases **must not** prompt users directly.
- If user input is needed, return an `InteractionRequest`: `ConfirmRequest`, `SelectRequest`, `InputRequest`
- UI resolves it (Rich prompts) and re-calls the use case with the user's decision.
- Prompt labels/hotkeys/BACK semantics must be preserved via characterization tests.

## Presenters are Edge-Only
- "Presenter" means: **mapping helpers** at the edge (CLI/UI), not ports.
- JSON mapping lives only in CLI/UI, centralized under `presentation/json/`.

## Logging & Output Boundaries
- Application code may use stdlib `logging.getLogger(__name__)`.
- Application must never call `console.print`, `typer.echo`, or `print`.
- Human-facing messaging is returned as view models/events and rendered at edges.

## IO Boundaries
- Application uses ports for IO:
  - `Filesystem` (no direct `Path.read_text/write_text`)
  - `GitClient` (no direct subprocess)
  - `RemoteFetcher` (no direct requests/httpx)
  - `ArchiveWriter` (no direct zipfile)
- Enforced by architectural invariants tests.

---

# CODE STYLE RULES

## Formatting / Linting
- Use `uv run ruff format` for formatting.
- Use `uv run ruff check` for lint rules.
- Use `collections.abc.Iterable/Sequence` instead of `typing.Iterable/Sequence`.

## Typing
- New `application/` and `ports/` code must be fully typed.
- No `Any` in application code unless extremely localized (edge JSON mapping is allowed).
- Use `Protocol` for ports; use dataclasses for domain models.
- If you need a `type: ignore`, always include the specific code and a short reason.

## Docstrings
- Public functions/classes in `application/` and `ports/` get docstrings that include:
  - what it does (in domain terms)
  - invariants ("must preserve behavior X")
  - inputs/outputs
  - raises (`SCCError` types)

## Comments
- Comments explain **why**, not what.
- Any place where behavior must remain stable (JSON fields, prompt text) should mention which tests lock it.

---

# FOLDER CONVENTIONS

- `src/scc_cli/application/` — use cases, state machines, orchestration (pure-ish)
- `src/scc_cli/ports/` — Protocols + domain-shaped types
- `src/scc_cli/adapters/` — concrete IO implementations (docker/git/http/fs/zip/etc.)
- `src/scc_cli/presentation/json/` — JSON mapping helpers (edge-only)
- `src/scc_cli/ui/` — Rich rendering + interactive prompts/pickers (no business rules)
- `src/scc_cli/commands/` — Typer entrypoints (thin wrappers)

---

# CODEBASE PATTERNS

- Use `uv run` for all Python commands
- Ports are Protocols in `src/scc_cli/ports/`
- Adapters implement ports in `src/scc_cli/adapters/`
- Use cases go in `src/scc_cli/application/<domain>/use_cases.py`
- Tests patch `_build_*_dependencies` or `*_use_cases.*` rather than old `git.*/deps.*` paths
- DefaultAdapters in bootstrap wires all adapters including dependency_installer
- InteractionRequests (ConfirmRequest, SelectRequest, InputRequest) for user prompts from use cases
- WorktreeDependencies pattern works well for dependency injection in commands
- Selection/confirmation loops in CLI stay in commands layer, use cases return data

---

# PHASE ACCEPTANCE CRITERIA

## Phase 3 Cleanup (Current)
- All ruff errors fixed
- All mypy errors fixed
- All pytest tests pass
- No unused variables in test files

## Phase 4 - Launch Flow Split
- Create `application/launch/` package with use cases
- Wizard is a state machine with explicit states
- Wizard transitions are fully unit-testable without UI mocks
- `flow.py` is dramatically smaller and easier to reason about
- JSON envelope unchanged (add characterization tests)
- `start --dry-run` output unchanged (add characterization test)

## Phase 5 - Support Bundle
- Create `application/support_bundle.py` use case
- Introduce DoctorRunner and ArchiveWriter ports
- Extract redaction logic into pure helpers
- Support bundle generation can be tested without real system dependencies
- JSON envelope unchanged

## Phase 6 - Typed Config Models
- Define NormalizedOrgConfig, NormalizedTeamConfig, NormalizedProjectConfig
- Parse/validate once at config load edges
- Application logic no longer depends on raw dict config structures
- Fewer "stringly typed" policy failures

## Phase 7 - Cleanup and Polish
- Consolidate time formatting
- Replace magic strings with enums/constants
- Add ConfigStore port
- Tighten optional dependency import discipline
- Commands/UI remain thin; application remains pure-ish and testable

---

# CURRENT STATE

## Completed Phases
- Phase 0 (Guardrails): presentation/json/ package, InteractionRequest schema, filesystem contract tests, architectural invariants tests - DONE
- Phase 1 (Sessions Store): SessionStore port, JSON adapter, typed models, SessionService use case - DONE
- Phase 2 (Workspace Resolver): application/workspace/ with ResolveWorkspace and ValidateWorkspace, unified resolver, PlatformProbe port - DONE
- Phase 3 (Worktree Use Cases): Implementation DONE, but has lint/test issues to fix

## Phase 3 - What Was Already Implemented
- `src/scc_cli/application/worktree/use_cases.py` - ListWorktrees, SelectWorktree, SwitchWorktree, CreateWorktree, EnterWorktreeShell
- `src/scc_cli/application/worktree/__init__.py` - exports
- `src/scc_cli/ports/dependency_installer.py` - DependencyInstaller Protocol
- `src/scc_cli/adapters/local_dependency_installer.py` - LocalDependencyInstaller
- Extended `src/scc_cli/ports/git_client.py` with worktree/branch operations
- Updated `src/scc_cli/adapters/local_git_client.py` with implementations
- `src/scc_cli/services/git/worktree.py` - fetch_branch, add_worktree, remove_worktree, prune_worktrees
- Refactored `src/scc_cli/commands/worktree/worktree_commands.py` to use use cases + WorktreeDependencies
- Updated `src/scc_cli/commands/launch/workspace.py` to use DependencyInstaller
- `tests/test_worktree_use_cases.py` - new unit tests
- Updated `tests/conftest.py` with worktree_dependencies fixture

## Known Issues to Fix (Phase 3 Cleanup)
1. **ruff import sorting errors** in:
   - `src/scc_cli/application/worktree/__init__.py`
   - `tests/test_worktree_use_cases.py`

2. **typing imports** - Replace `typing.Iterable/Sequence` with `collections.abc` in:
   - `src/scc_cli/application/worktree/use_cases.py`

3. **Unused variables** in `tests/test_worktree_cli.py`:
   - Remove `dependencies, _ = worktree_command_dependencies` lines where unused

4. **Failing tests** in `tests/test_cli.py` and `tests/test_integration.py`:
   - `test_start_with_install_deps_runs_dependency_install` - dependency_installer.install not called
   - `test_start_with_install_deps` - dependency_installer.install not called
   - Fix by patching `_build_worktree_dependencies` or ensuring DefaultAdapters includes dependency_installer correctly

---

# DEFINITION OF 10/10 MAINTAINABILITY (Final Goals)

- Commands are thin wrappers (no business logic)
- Application use cases are testable with fakes (no docker/git/network)
- IO only in adapters or CLI/UI edges
- Workspace resolution is unified (one authoritative entry point)
- Sessions persistence is typed and port-based
- Worktree flows are use-case driven and deterministic ✓
- Launch wizard is a state machine with explicit transitions
- InteractionRequest schema is stable and tested for labels/hotkeys/BACK
- JSON mapping is centralized in `presentation/json` and stays at edges
- Error strategy is consistent: use cases raise `SCCError`, edges map
- Architectural invariants + filesystem contracts are enforced by tests

---

# REFERENCE FILES

For more detailed information, read these files:
- `MAINTAINABILITY_IMPLEMENTATION_PLAN.md` - The full implementation plan with all details
- `src/scc_cli/application/worktree/use_cases.py` - Example of properly structured use cases
- `src/scc_cli/ports/` - Example port definitions
- `tests/test_worktree_use_cases.py` - Example of testing use cases with fakes

---

# LEARNINGS LOG

## 2025-01-17
- WorktreeDependencies pattern works well for dependency injection in commands
- Selection/confirmation loops in CLI stay in commands layer, use cases return data
- Patches must target new injection points (`_build_worktree_dependencies`, `worktree_use_cases.*`), not old `git.*/deps.*` paths
- Always run full validation after each change
- Established pattern: ports -> adapters -> use cases -> thin commands
- InteractionRequests work well for decoupling prompts from business logic
- Characterization tests are essential before refactoring

---

## 2026-01-18
- Fixed worktree use case import ordering, removed redundant branch handling in worktree switch.
- Swapped worktree CLI tests to index-only dependency access to avoid unused tuple unpacking.
- Cleaned up dependency installer wiring in launch workspace preparation and confirmed start --install-deps tests.
- Added application/launch SelectSession use case with interaction request prompt model.
- Added application/launch start wizard state machine with explicit states and tests.
- Validation: `uv run ruff format`, `uv run ruff check`, `uv run mypy src/scc_cli`, `uv run pytest`.

